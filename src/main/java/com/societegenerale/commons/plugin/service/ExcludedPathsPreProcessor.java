package com.societegenerale.commons.plugin.service;

import java.io.IOException;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.societegenerale.commons.plugin.Log;
import com.tngtech.archunit.thirdparty.com.google.common.annotations.VisibleForTesting;
import org.apache.commons.io.FilenameUtils;


/**
 * This class analyses exclusion paths : this is especially useful for generated source code.
 *
 * It looks in directories and sub directories for java files and collects them to an exclusion set.
 * By listing all the source files to be excluded, we can reuse that list later when the compiled generated classes
 * are mixed with the non-generated classes.
 */
class ExcludedPathsPreProcessor implements Serializable
{
    private static final String FILE_TYPE_JAVA = ".java";

    static final String GENERATED_SOURCES = "generated-sources";
    static final String PACKAGE_INFO_JAVA  = "package-info.java";

    /**
     * This method analyses the <code>excludedPaths</code>. It looks into directories and sub directories for java files
     * and collects them to an exclusion set. The directories which containing java files will be replaced by class
     * names generated by the java files.
     *
     * @param logger     - not null
     * @param projectBuildDir - the target folder
     * @param excludedPaths   - relative or absoltue paths or the keywords generated-test-sources, generated-sources
     *
     * @return a set of classes to be exclude, not null
     */
    public Set<String> processExcludedPaths(@Nonnull final Log logger, final String projectBuildDir,
                                     final Collection<String> excludedPaths)
    {
        final Set<String> result = excludedPaths != null ? new HashSet<>(excludedPaths) : new HashSet<>();
        if (excludedPaths == null)
        {
            return result;
        }

        logger.debug("projectBuildDir: " + projectBuildDir);

        final String targetDir = projectBuildDir != null ? projectBuildDir.trim() : "";

        for (final String pathAsString : excludedPaths)
        {
            final Path path = convertToPath(logger, targetDir, pathAsString.trim());
            final Set<Path> javaFiles = findJavaFiles(path, logger);

            final Set<String> classNames = determineClassNames(javaFiles, logger);
            result.addAll(classNames);
        }

        return result;
    }

    /**
     * Searchs for *.java files in the given path and sub paths.
     *
     * @param path - a filesystem path
     *
     * @return a set of java files, not null
     */
    @VisibleForTesting
    Set<Path> findJavaFiles(final Path path, @Nonnull final Log logger)
    {
        Set<Path> files = new HashSet<>();
        try
        {
            if (path != null)
            {
                if (Files.isDirectory(path))
                {
                    // search in directories and collect all java files
                    files = Files.find(path, Integer.MAX_VALUE,
                                       (p, basicFileAttributes) -> isJavaFile(p.toString()))
                                 .collect(Collectors.toSet());
                }
                else
                {
                    // is it a java file?                                                                    
                    if (isJavaFile(path.toString()))
                    {
                        files.add(path);
                    }
                }
            }
        }
        catch (final IOException e)
        {
            logger.warn("unable to collect java files in path: " + path, e);
        }

        return files;
    }

    @VisibleForTesting
    boolean isJavaFile(final String pathString)
    {
        final String path = pathString != null ? pathString.toLowerCase().trim() : "";
        return !path.endsWith(PACKAGE_INFO_JAVA) && path.endsWith(FILE_TYPE_JAVA);
    }

    /**
     * Tries to determine a directory path.
     *
     * @param projectBuildDir - project build directory, not null
     * @param pathAsString    - a string which could be a directory path or a file path or part of path (projectBuildDir
     *                        + pathAsString), not null
     *
     * @return the {@link Path}
     *
     * @throws InvalidPathException if pathAsString cannot be converted into a {@link Path}
     */
    @Nullable
    @VisibleForTesting
    Path convertToPath(@Nonnull final Log logger, final String projectBuildDir, @Nonnull final String pathAsString)
            throws InvalidPathException
    {
        Path result;

        // if pathAsString itself represents a valid path
        try
        {
            result = Paths.get(pathAsString);
            if (Files.exists(result))
            {
                return result;
            }
        }
        catch (final InvalidPathException e)
        {
            logger.debug("invalid path: " + pathAsString, e);
        }

        // maybe the combination of projectBuildDir and pathAsString is a valid path
        try
        {
            final String concatPath = FilenameUtils.concat(projectBuildDir, pathAsString);
            logger.debug("concatPath: " + concatPath);
            result = Paths.get(concatPath);

            if (!Files.exists(result))
            {
                logger.warn("invalid exclusion path: " + concatPath);
                result = null;
            }
        }
        catch (final InvalidPathException e)
        {
            logger.warn("invalid path: " + pathAsString, e);
            result = null;
        }

        return result;
    }

    /**
     * Determine the class names by given java files (package.filename). In assumption that the file is equal to the
     * class name within the file content.
     *
     * @param javaFilePaths -   not null
     * @param logger   -   not null
     *
     * @return not null
     */
    @VisibleForTesting
    Set<String> determineClassNames(final Set<Path> javaFilePaths, final Log logger)
    {
        final JavaFileParser fileParser = new JavaFileParser();

        final Set<String> packageWithClassNames = new HashSet<>();

        for (final Path path : javaFilePaths)
        {
            final JavaFileParser.JavaFile file;
            try
            {
                file = fileParser.parse(path, logger);

                if (file.getClassName() != null)
                {
                    final String packageWithClassName =
                            file.getPackageString() != null ? file.getPackageString() + "." + file.getClassName() :
                            file.getClassName();
                    packageWithClassNames.add(packageWithClassName);
                }
            }
            catch (final IOException e)
            {
                logger.warn("unable to read file: " + path);
            }
        }

        return packageWithClassNames;
    }

}
